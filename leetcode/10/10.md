<!--
 @Description: 10 analyse
 @Author: Yihao Wang
 @Date: 2020-01-06 18:07:51
 * @LastEditors  : Yihao Wang
 * @LastEditTime : 2020-01-06 20:53:20
 -->
# 10题解
本题是一个DP问题, 主要是围绕两个问题来进行说明:
1. 为什么本问题是DP问题
2. 如何进行状态转换

#### 问题1
首先字符串匹配, 它具备无后效性问题, 即前面已经被设定为匹配的字符串不会对后面需要匹配的字符串产生影响,而且本问题也是对于.和*或者字符本身这三类子问题的反复求解;其次是最优子结构问题, 因为若是一个字符串可以匹配, 不会存在另一种更优匹配方法, 因为输出结果需要字符串的整体匹配, 子字符串匹配成功不代表整体字符串匹配成功, 所以若是某个解是最优解, 则其前缀字符串必然也是最优解.

#### 问题2
借用discuss里面的伪代码:
```c++
f[i][j]: if s[0..i-1] matches p[0..j-1]
if p[j - 1] != '*'
     f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]
if p[j - 1] == '*', denote p[j - 2] with x
     f[i][j] is true iff any of the following is true
     1) "x*" repeats 0 time and matches empty: f[i][j - 2]
     2) "x*" repeats >= 1 times and matches "x*x": s[i - 1] == x && f[i - 1][j]
'.' matches any single characterc++
```
PS:以下说明要注意f[i][j]代表s[0..i-1]是否匹配p[0..j-1]而不是代表s[0..i]是否匹配p[0..j]
1. 若当前匹配字符不为*, 则可能为.或者字符本身, 且.可以看成任意字符, 所以只需验证s[i-1]是否等于p[j-1]
2. 若当前匹配字符是*, 则粉两种情况, 第一, s[i-1]是否可以匹配p[j-3], 即p[j-2]\(任意字符)和p[j-1]\(\*字符)视为**重复了0次的空字符串**; 第二, 若以上情况不满足, 则进行如下展开:
    设p[j-1]为x, 则p[j-1]和p[j]等价为x*, 又因为已经不满足x\*为空时候的表达式, 所以可以再次等价为x\*x, 那么情况2变成首先检验s\[i-1]是否为x字符, 然后检验s[i-2]是否匹配p[j-1]

循环至字符串结束之后, 访问f[s_length][p_length]则可获得输出结果